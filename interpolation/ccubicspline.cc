//****************************************************************************************************
//подключаемые библиотеки
//****************************************************************************************************
#include "ccubicspline.h"
#include "cstep.h"
#include <vector>

//****************************************************************************************************
//глобальные переменные
//****************************************************************************************************

//****************************************************************************************************
//константы
//****************************************************************************************************

//****************************************************************************************************
//макроопределения
//****************************************************************************************************

//****************************************************************************************************
//конструктор и деструктор
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//конструктор
//----------------------------------------------------------------------------------------------------
CCubicSpline::CCubicSpline(void)
{
}

//----------------------------------------------------------------------------------------------------
//деструктор
//----------------------------------------------------------------------------------------------------
CCubicSpline::~CCubicSpline()
{
}
//****************************************************************************************************
//закрытые функции
//****************************************************************************************************

//****************************************************************************************************
//открытые функции
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//выполнить интерполяцию
//----------------------------------------------------------------------------------------------------
bool CCubicSpline::Execute(const std::vector<CGrPoint> &input,std::vector<CGrPoint> &output,long double step)
{
 size_t size=input.size();
 output.clear();
 std::vector<CGrPoint> empty;
 output.swap(empty);

 if (size<3) return(false);//кубический сплайн невозможно построить по такому числу точек
 if (step==0) return(false);//чёткий ноль использовать нельзя
 size_t min_amount=(input[size-1].X-input[0].X)/step+1;
 output.reserve(min_amount);

 //коэффициенты трёхдиагональной матрицы (ABC) и вспомогательных векторов (Q,W,R,F)
 std::vector<long double> Q(size);
 std::vector<long double> W(size);
 std::vector<long double> A(size);
 std::vector<long double> B(size);
 std::vector<long double> C(size);
 std::vector<long double> R(size);
 std::vector<long double> F(size);

 //производим подготовку к вычислению сплайна
 //инициализируем матрицу коэффициентов
 for(size_t n=0;n<size-1;n++)
 {
  long double xm1=input[n-1].X;
  long double x0=input[n].X;
  long double x1=input[n+1].X;

  long double h2=x1-x0;
  long double h1=h2;
  if (n>0) h1=x0-xm1;
  A[n]=h1/6.0;
  B[n]=h2/6.0;
  C[n]=h1/3.0+h2/3.0;
 }
 //вычисляем вспомогательные вектора
 for(size_t n=1;n<size-1;n++)
 {
  long double xm1=input[n-1].X;
  long double ym1=input[n-1].Y;

  long double x0=input[n].X;
  long double y0=input[n].Y;

  long double x1=input[n+1].X;
  long double y1=input[n+1].Y;

  long double h1=x0-xm1;
  long double h2=x1-x0;
  F[n]=ym1/h1-y0/h2-y0/h1+y1/h2;
 }
 F[0]=F[1];
 //начальные условия
 R[0]=0;
 R[size-1]=0;
 //решаем систему уравнений методом прогонки
 Q[1]=-B[0]/C[0];
 W[1]=F[0]/C[0];
 for(size_t n=1;n<size-2;n++)
 {
  Q[n+1]=-B[n]/(A[n]*Q[n]+C[n]);
  W[n+1]=(-A[n]*W[n]+F[n])/(A[n]*Q[n]+C[n]);
 }
 size_t e=size-2; 
 R[e]=(F[e]-A[e]*W[e])/(C[e]+A[e]*Q[e]);
 for(size_t n=e-1;n>0;n--) R[n]=R[n+1]*Q[n+1]+W[n+1];
 R[0]=R[1]*Q[1]+W[1];
 //вычисляем сплайн в заданных точках

 CStep cStep(size-2,step,input);
 long double x;
 size_t point;

 //коэффициенты полинома
 long double a;
 long double b;
 long double c;
 long double d;

 bool first_step=true;

 while(1)
 {
  bool change_point=cStep.UpdatePoint();
  cStep.GetPos(x,point);

  long double x0=input[point].X;
  long double y0=input[point].Y;

  long double x1=input[point+1].X;
  long double y1=input[point+1].Y;

  long double h=x1-x0;
  long double dx1=x1-x;
  long double dx2=x-x0;

  if (change_point==true || first_step==true)//требуется пересчитать полином
  {
   first_step=false;
   a=R[point]/(6.0*h);
   b=R[point+1]/(6.0*h);
   c=(y1-R[point+1]*h*h/6.0)/h;
   d=(y0-R[point]*h*h/6.0)/h;
  }

  long double y=a*dx1*dx1*dx1;
  y+=b*dx2*dx2*dx2;
  y+=c*dx2;
  y+=d*dx1;
  output.push_back(CGrPoint(x,y));

  if (cStep.NextStep()==false) break;
 }
 return(true);
}



